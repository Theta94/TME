package tme.model.merge;

import java.util.Set;
import java.util.HashSet;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

class ChurnMethod {
    private String key;
    private String name;
    private String _package;
    private String _class;
    private String file;
    private float linesOfCode;
    private int addedLines;
    private int deletedLines;
    private int changedLines;
    private float complexity;
    private int startLine;
    private int endLine;
    private String type;
    private String status;
    private String signature;
    
    public ChurnMethod() { }
    
    public void setKey(String key) {
        this.key = key;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void setPackage(String _package) {
        this._package = _package;
    }
    
    public void setClass(String _class) {
        this._class = _class;
    }
    
    public void setFile(String file) {
        this.file = file;
    }
    
    public void setLinesOfCode(float linesOfCode) {
        this.linesOfCode = linesOfCode;
    }
    
    public void setAddedLines(int addedLines) {
        this.addedLines = addedLines;
    }
    
    public void setDeletedLines(int deletedLines) {
        this.deletedLines = deletedLines;
    }
    
    public void setChangedLines(int changedLines) {
        this.changedLines = changedLines;
    }
    
    public void setComplexity(float complexity) {
        this.complexity = complexity;
    }
    
    public void setEndLine(int endLine) {
        this.endLine = endLine;
    }
    
    public void setStartLine(int startLine) {
        this.startLine = startLine;
    }
    
    public void setType(String type) {
        this.type = type;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public void setSignature(String signature) {
        this.signature = normalizeSignature(signature, getName());
    }
    
    public String getKey() {
        return key;
    }
    
    public String getName() {
        return name;
    }
    
    public String getPackage() {
        return _package;
    }
    
    public String _getClass() {
        return _class;
    }
    
    public String getFile() {
        return file;
    }
    
    public float getLinesOfCode() {
        return linesOfCode;
    }
    
    public int getAddedLines() {
        return addedLines;
    }
    
    public int getDeletedLines() {
        return deletedLines;
    }
    
    public int getChangedLines() {
        return changedLines;
    }
    
    public float getComplexity() {
        return complexity;
    }
    
    public int getEndLine() {
        return endLine;
    }
    
    public int getStartLine() {
        return startLine;
    }
    
    public String getType() {
        return type;
    }
    
    public String getStatus() {
        return status;
    }
    
    public String getSignature() {
        return signature;
    }
    
    private static String normalizeSignature(String signature, String name) {
        String normalized = signature;
        
        normalized = normalized.substring(normalized.lastIndexOf(name) + name.length());
        normalized = normalized.replace("(", "");
        normalized = normalized.replace(")", "");
        normalized = normalized.replace("L", "");
        
        return normalized;
    }
}

/**
 * This class is designed to parse a churnTool report in XML format. 
 * The idea is to represent each element node as a Class and each element attribute as a class attribute,
 * after that it's easy to create a DOM data structure that will contains the XML file and parse it inside support's classes.<br><br>
 * 
 * The report generated by churnTool has the following element nodes: <code>method, key, name, package, class, file, linesOfCode, addedLines, deletedLines, changedLines,
 * complexity, startLine, endLine, type and status</code>.<br>
 * The method node has been represented as a class and the others as its attributes.<br><br>
 * 
 * The parsing operation should be very fast due to the class simply add the methods to a set.
 * @see javax.xml.parsers
 * @see org.w3c.dom
 * @author Maurizio Cimino
 */
public final class ParsedChurn {
    private final Set<ChurnMethod> methods;
    private final Node rootNode;
    
    /**
     * It creates a ParsedChurn object that will parse from specified <code>fileName</code> path.
     * 
     * @param fileName the path to open the XML file to parse.
     */
    public ParsedChurn(Node root) {
        methods = new HashSet<ChurnMethod>();
        rootNode = root;
    }
    
    /**
     * 
     * @return the value of fileName attribute.
     */
    Node getRootNode() {
        return rootNode;
    }
    
    /**
     * 
     * @return the set that contains all the parsed methods.
     */
    Set<ChurnMethod> getMethods() {
        return methods;
    }
    
    /**
     * It parse a method node element.
     * 
     * @param node the node to parse.
     */
    private void parseMethodNode(Node node) {
        // Check if the input node is an element
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            // The cast allows you to access to this node's informations
            Element element = (Element)node;
            // Check if this element is the right one ('Method')
            if (element.getNodeName().equals("Method")) {
                // Create a new ChurnMethod object
                ChurnMethod cm = new ChurnMethod();
                // Take all the childrens of this node
                NodeList currentNodes = node.getChildNodes();
                // Iterate all over the childrens
                for (int i = 0; i < currentNodes.getLength(); i++) {
                    // Access to this node
                    Node currentNode = currentNodes.item(i);
                     // Check if this node is an element
                     if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                         // Access the informations of this node
                         Element currentElement = (Element)currentNode;
                         // Check if this element is a key
                         if (currentElement.getNodeName().equals("key"))
                             cm.setKey(currentElement.getTextContent());
                         // Check if this element is a name
                         else if (currentElement.getNodeName().equals("name")) {
                             cm.setName(currentElement.getTextContent());
                             // Set the signature due to you have key and name now
                             cm.setSignature(cm.getKey());
                         }
                         // Check if this element is a package
                         else if (currentElement.getNodeName().equals("package"))
                             cm.setPackage(currentElement.getTextContent());
                         // Check if this element is a class
                         else if (currentElement.getNodeName().equals("class"))
                             cm.setClass(currentElement.getTextContent());
                         // Check if this element is a file
                         else if (currentElement.getNodeName().equals("file"))
                             cm.setFile(currentElement.getTextContent());
                         // Check if this element is a linesOfCode
                         else if (currentElement.getNodeName().equals("linesOfCode"))
                             cm.setLinesOfCode(Float.parseFloat(currentElement.getTextContent()));
                         // Check if this element is a addedLines
                         else if (currentElement.getNodeName().equals("addedLines"))
                             cm.setAddedLines(Integer.parseInt(currentElement.getTextContent()));
                         // Check if this element is a deletedLines
                         else if (currentElement.getNodeName().equals("deletedLines"))
                             cm.setDeletedLines(Integer.parseInt(currentElement.getTextContent()));
                         // Check if this element is a changedLines
                         else if (currentElement.getNodeName().equals("changedLines"))
                             cm.setChangedLines(Integer.parseInt(currentElement.getTextContent()));
                         // Check if this element is a complexity
                         else if (currentElement.getNodeName().equals("complexity"))
                             cm.setComplexity(Float.parseFloat(currentElement.getTextContent()));
                         // Check if this element is a startLine
                         else if (currentElement.getNodeName().equals("startLine"))
                             cm.setStartLine(Integer.parseInt(currentElement.getTextContent()));
                         // Check if this element is a endLine
                         else if (currentElement.getNodeName().equals("endLine"))
                             cm.setEndLine(Integer.parseInt(currentElement.getTextContent()));
                         // Check if this element is a type
                         else if (currentElement.getNodeName().equals("type"))
                             cm.setType(currentElement.getTextContent());
                         // Check if this element is a status
                         else if (currentElement.getNodeName().equals("status"))
                             cm.setStatus(currentElement.getTextContent());
                     }
                }
                // Add this new parsed method
                methods.add(cm);
            }
        }
    }
    
    /**
     * It parses an XML churnTool report file.
     */
    public void parseXMLChurn() {
        if (rootNode == null)
            throw new RuntimeException("You must specify a node to open.");
        
        // Access to the root node
        Node root = rootNode.getFirstChild();
        // Take all the childrens of this node ('Method')
        NodeList rootChildrenNodes = root.getChildNodes();
        // Iterate all over the childrens
        for (int i = 0; i < rootChildrenNodes.getLength(); i++) {
            // Take the current node
            Node currentNode = rootChildrenNodes.item(i);
            // Check if this node is an element
            if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                // Check the informations of this node
                Element currentElement = (Element)currentNode;
                // Check if this element is a Method
                if (currentElement.getNodeName().equals("Method"))
                    // Parse the method
                    parseMethodNode(currentNode);
            }
        } 
    }
    
    /**
     * 
     * @return the list of all the parsed methods.
     */
    @Override
    public String toString() {
        String ris = "";
        int counterMethods = 0;
        
        for (ChurnMethod cm : methods) {
            ris = ris + "Method: " + cm.getName() + "\n";
            counterMethods++;
        }
        ris = ris + "\nTotal Methods: " + counterMethods;
        
        return ris;
    }
}
