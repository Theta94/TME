package tme.model.merge;

import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

enum CounterTypeEnum {
    INSTRUCTION,
    BRANCH,
    LINE,
    COMPLEXITY,
    METHOD,
    CLASS
}

class Counter {
    private int missed;
    private int covered;
    private CounterTypeEnum type;
    
    public Counter() { }
    
    public Counter(String type, int missed, int covered) {
        setType(type);
        this.missed = missed;
        this.covered = covered;
    }
    
    public void setType(String type) {
        if (type.equals("INSTRUCTION"))
            this.type = CounterTypeEnum.INSTRUCTION;
        else if (type.equals("BRANCH"))
            this.type = CounterTypeEnum.BRANCH;
        else if (type.equals("LINE"))
            this.type = CounterTypeEnum.LINE;
        else if (type.equals("COMPLEXITY"))
            this.type = CounterTypeEnum.COMPLEXITY;
        else if (type.equals("METHOD")) 
            this.type = CounterTypeEnum.METHOD;
        else if (type.equals("CLASS"))
            this.type = CounterTypeEnum.CLASS;
        else
            this.type = null;
    }
    
    public void setMissed(int missed) {
        this.missed = missed;
    }
    
    public void setCovered(int covered) {
        this.covered = covered;
    }
    
    public int getMissed() {
        return missed;
    }
    
    public int getCovered() {
        return covered;
    }
    
    public CounterTypeEnum getType() {
        return type;
    }
}

abstract class ReportEntity {
    protected String name;
    protected final Set<Counter> counters;
    
    public ReportEntity() {
        name = null;
        counters = new HashSet<Counter>();
    }
    
    public ReportEntity(String name) {
        this.name = name;
        counters = new HashSet<Counter>();
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public Set<Counter> getCounters() {
        return counters;
    }
    
    protected boolean addCounter(String type, int missed, int covered) {
        Counter c = new Counter(type, missed, covered);
        counters.add(c);

        return true;
    }
}

class ReportPackage extends ReportEntity {
    
    public ReportPackage() {
        super();
    }
    
    public ReportPackage(String name) {
        super(name);
    }
}

class ReportClass extends ReportEntity {
    
    public ReportClass() {
        super();
    }
    
    public ReportClass(String name) {
        super(name);
    }
}

class ReportMethod extends ReportEntity {
    private String desc;
    private int line;
    private String signature;
    
    public ReportMethod() {
        super();
        desc = null;
        line = 0;
        signature = null;
    }
    
    public ReportMethod(String name, String desc, int line) {
        super(name);
        this.desc = desc;
        this.line = line;
        signature = normalizeSignature(desc);
    }
    
    public void setDesc(String desc) {
        this.desc = desc;
    }
    
    public void setLine(int line) {
        this.line = line;
    }
    
    public String getDesc() {
        return desc;
    }
    
    public int getLine() {
        return line;
    }
    
    public String getSignature() {
        return signature;
    }
    
    private static String normalizeSignature(String signature) {
        String normalized = signature;
        
        normalized = normalized.replace("(", "");
        normalized = normalized.replace(")", "");
        normalized = normalized.replace("L", "");
        
        return normalized;
    }
}

/**
 * This class is designed to parse a JaCoCo report in XML format. 
 * The idea is to represent each element node as a Class and each element attribute as a class attribute,
 * after that it's easy to create a DOM data structure that will contains the XML file and parse it inside support's classes.<br><br>
 * 
 * The report generated by JaCoCo has the following element nodes: <code>package, class, method, counter, sourcefile and line</code><br>
 * The first four have been considered into the parsing operation; you can find each representation as an object.<br><br>
 * 
 * The parsing operation should be very fast due to the class used maps as main data structures.
 * 
 * @author Maurizio Cimino
 * @see javax.xml.parsers
 * @see org.w3c.dom
 */

public final class ParsedReport {
    private final Map<ReportPackage, Set<ReportClass>> packageToClass;
    private final Map<ReportClass, Set<ReportMethod>> classToMethod;
    private final Node nodeRoot;
    
    /**
     * It creates a ParsedReport object that will parse from specified <code>fileName</code> path.
     * 
     * @param fileName the path to open the XML file to parse.
     */
    public ParsedReport(Node root) {
        packageToClass = new HashMap<ReportPackage, Set<ReportClass>>();
        classToMethod = new HashMap<ReportClass, Set<ReportMethod>>();
        nodeRoot = root;
    }
    
    /**
     * 
     * @return the value of fileName attribute.
     */
    Node getRoot() {
        return nodeRoot;
    }
    
    /**
     * 
     * @return the map that creates the corrispondence from packages to classes.
     */
    Map<ReportPackage, Set<ReportClass>> getPackageToClass() {
        return packageToClass;
    }
    
    /**
     * 
     * @return the map that creates the corrispondence from classes to methods. 
     */
    Map<ReportClass, Set<ReportMethod>> getClassToMethod() {
        return classToMethod;
    }
    
    /**
     * It parse a method node element.
     * 
     * @param node the node to parse.
     * @param rm a ReportMethod object that represents the parsed method.
     * @param rc a ReportClass object that rapresents the parsed class.
     */
    private void parseMethodNode(Node node, ReportMethod rm, ReportClass rc) {
        // Check if the input node is an element
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            // The cast allows you to access to this node's informations
            Element element = (Element)node;
            // Check if this element is the right one ('method')
            if (element.getNodeName().equals("method")) {
                // Create a new ReportMethod object containing this node's informations
                rm = new ReportMethod(element.getAttribute("name"), element.getAttribute("desc"), Integer.parseInt(element.getAttribute("line")));
                // Add this method in the correct class's map position
                classToMethod.get(rc).add(rm);
                // Take all the childrens of this node ('counter' nodes)
                NodeList countersNodes = node.getChildNodes();
                // Iterate all over the childrens
                for (int i = 0; i < countersNodes.getLength(); i++) {
                    // The unique childrens of 'method' nodes are 'counters'
                    Node counterNode = countersNodes.item(i);
                    // Check if this node is an element
                    if (counterNode.getNodeType() == Node.ELEMENT_NODE) {
                        // Access the informations of this node
                        Element currentElement = (Element)counterNode;
                        // Check if this element is a counter
                        if (currentElement.getNodeName().equals("counter"))
                            // Add this counter to the method
                            rm.addCounter(currentElement.getAttribute("type"), Integer.parseInt(currentElement.getAttribute("missed")), Integer.parseInt(currentElement.getAttribute("covered")));
                    }
                }
            }
        }
    }
    
    /**
     * It parse a class node element.
     * 
     * @param node the node to parse.
     * @param rp a ReportPackage object that represents the parsed package.
     * @param rm a ReportMethod object that represents the parsed method.
     * @param rc a ReportClass object that rapresents the parsed class.
     */
    private void parseClassNode(Node node, ReportPackage rp, ReportClass rc, ReportMethod rm) {
        // Check if the input node is an element
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            // The cast allows you to access to this node's informations
            Element element = (Element)node;
            // Check if this element is the right one ('class')
            if (element.getNodeName().equals("class")) {
                // Create a new ReportClass object containing this node's informations
                rc = new ReportClass(element.getAttribute("name"));
                // Allocate a set of methods in the map for this class
                classToMethod.put(rc, new HashSet<ReportMethod>());
                // Add this class in the right packages's map position
                packageToClass.get(rp).add(rc);
                // Take all the childrens of this node ('counter' and 'method')
                NodeList classChildrenNodes = node.getChildNodes();
                // Iterate all over the childrens
                for (int i = 0; i < classChildrenNodes.getLength(); i++) {
                    // Take the current node
                    Node currentNode = classChildrenNodes.item(i);
                    // Check if this node is an element
                    if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                        // Access the informations of this node
                        Element currentElement = (Element)currentNode;
                        // Check if this element is a method
                        if (currentElement.getNodeName().equals("method"))
                            // Parse the method
                            parseMethodNode(currentNode, rm, rc);
                        // Check if this element is a counter
                        else if (currentElement.getNodeName().equals("counter"))
                            // Add this counter to the class
                            rc.addCounter(currentElement.getAttribute("type"), Integer.parseInt(currentElement.getAttribute("missed")), Integer.parseInt(currentElement.getAttribute("covered")));
                    }
                }
            }
        }
    }
    
    /**
     * It parse a package node element.
     * 
     * @param node the node to parse.
     * @param rp a ReportPackage object that represents the parsed package.
     * @param rm a ReportMethod object that represents the parsed method.
     * @param rc a ReportClass object that rapresents the parsed class.
     */
    private void parsePackageNode(Node node, ReportPackage rp, ReportClass rc, ReportMethod rm) {
        // Check if the input node is an element
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            // The cast allows you to access to this node's informations
            Element element = (Element)node;
            // Check if this element is the right one ('package')
            if (element.getNodeName().equals("package")) {
                // Create a new ReportPackage object containing this node's informations
                rp = new ReportPackage(element.getAttribute("name"));
                // Allocate a set of classes in the map for this package
                packageToClass.put(rp, new HashSet<ReportClass>());
                // Take all the childrens of this node ('counter', 'class' and 'sourcefile')
                NodeList packageChildrenNodes = node.getChildNodes();
                // Iterate all over the childrens
                for (int i = 0; i < packageChildrenNodes.getLength(); i++) {
                    // Take the current node
                    Node currentNode = packageChildrenNodes.item(i);
                    // Check if this element is a node
                    if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                        // Access the informations of this node
                        Element currentElement = (Element)currentNode;
                        // Check if this element is a sourcefile
                        if (currentElement.getNodeName().equals("sourcefile")) { } // Do Nothing
                        // Check if this element is a class
                        else if (currentElement.getNodeName().equals("class"))
                            // Parse the class
                            parseClassNode(currentNode, rp, rc, rm);
                        // Check if this element is a counter
                        else if (currentElement.getNodeName().equals("counter"))
                            // Add this counter to the class
                            rp.addCounter(currentElement.getAttribute("type"), Integer.parseInt(currentElement.getAttribute("missed")), Integer.parseInt(currentElement.getAttribute("covered")));
                    }
                }
            }
        }
    }
    
    /**
     * It parses an XML JaCoCo report file.
     */
    public void parseXMLReport() {
        if (nodeRoot == null)
            throw new RuntimeException("You must specify a node");
        
        // "Global" variables for parsing methods
        ReportPackage rp = null;
        ReportClass rc = null;
        ReportMethod rm = null;

        // Take all the childrens of this node ('sessioninfo', and 'package')
        Node root = nodeRoot.getFirstChild();
        NodeList rootChildrenNodes = root.getChildNodes();
        // Iterate all over the childrens
        for (int i = 0; i < rootChildrenNodes.getLength(); i++) {
            // Take the current node
            Node currentNode = rootChildrenNodes.item(i);
            // Check if this node is an element
            if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                // Check the informations of this node
                Element currentElement = (Element)currentNode;
                // Check if this element is a sessioninfo
                if (currentElement.getNodeName().equals("sessioninfo")) { } // Do Nothing
                // Check if this element is a counter
                else if (currentElement.getNodeName().equals("counter")) { } // Do Nothing
                // Check if this element is a package
                else if (currentElement.getNodeName().equals("package")) {
                    // Parse the package
                    parsePackageNode(currentNode, rp, rc, rm);
                }
            }
        } 
    }
    
    /**
     * 
     * @return the description of all packages, classes and mathods parsed.
     */
    @Override
    public String toString() {
        String ris = "";
        int packages = 0, classes = 0, methods = 0;
        
        for (ReportPackage rp : packageToClass.keySet()) {
            ris = ris + "Package name: " + rp.getName() + "\n";
            packages++;
            for (ReportClass rc : packageToClass.get(rp)) {
                ris = ris + "  Class name: " + rc.getName() + "\n";
                classes++;
                for (ReportMethod rm : classToMethod.get(rc)) {
                    ris = ris + "    Method name: " + rm.getName() + "\n";
                methods++;
                }
            }
        }
        ris = ris + "\nTotal packages: " + packages + "\nTotal classes: " + classes + "\nTotal methods: " + methods;
        
        return ris;
    }
}